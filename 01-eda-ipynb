{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "943e95c4",
   "metadata": {
    "_cell_guid": "f359e460-5658-4df0-ae76-dae5ab1e4217",
    "_uuid": "d4fe65a7-ecce-49c1-a73e-309ace11deba",
    "collapsed": false,
    "execution": {
     "iopub.execute_input": "2025-12-31T21:36:18.055104Z",
     "iopub.status.busy": "2025-12-31T21:36:18.054685Z",
     "iopub.status.idle": "2025-12-31T21:36:18.059503Z",
     "shell.execute_reply": "2025-12-31T21:36:18.058761Z"
    },
    "jupyter": {
     "outputs_hidden": false
    },
    "papermill": {
     "duration": 0.011599,
     "end_time": "2025-12-31T21:36:18.061201",
     "exception": false,
     "start_time": "2025-12-31T21:36:18.049602",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# # This Python 3 environment comes with many helpful analytics libraries installed\n",
    "# # It is defined by the kaggle/python Docker image: https://github.com/kaggle/docker-python\n",
    "# # For example, here's several helpful packages to load\n",
    "\n",
    "# import numpy as np # linear algebra\n",
    "# import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)\n",
    "\n",
    "# # Input data files are available in the read-only \"../input/\" directory\n",
    "# # For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n",
    "\n",
    "# import os\n",
    "# for dirname, _, filenames in os.walk('/kaggle/input'):\n",
    "#     for filename in filenames:\n",
    "#         print(os.path.join(dirname, filename))\n",
    "\n",
    "# # You can write up to 20GB to the current directory (/kaggle/working/) that gets preserved as output when you create a version using \"Save & Run All\" \n",
    "# # You can also write temporary files to /kaggle/temp/, but they won't be saved outside of the current session"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "5c1554fd",
   "metadata": {
    "_cell_guid": "a7c6a5d1-8959-4210-8ad1-1a97420747f2",
    "_uuid": "d0ade4b7-7960-4103-9c19-458aa1cbc34f",
    "collapsed": false,
    "execution": {
     "iopub.execute_input": "2025-12-31T21:36:18.068398Z",
     "iopub.status.busy": "2025-12-31T21:36:18.067794Z",
     "iopub.status.idle": "2025-12-31T21:36:21.373591Z",
     "shell.execute_reply": "2025-12-31T21:36:21.372448Z"
    },
    "jupyter": {
     "outputs_hidden": false
    },
    "papermill": {
     "duration": 3.311604,
     "end_time": "2025-12-31T21:36:21.375703",
     "exception": false,
     "start_time": "2025-12-31T21:36:18.064099",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "OUT_DIR: /kaggle/working/3w_prepared_v3_1\n"
     ]
    }
   ],
   "source": [
    "import os, re, json\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "from tqdm.auto import tqdm\n",
    "\n",
    "from sklearn.model_selection import StratifiedGroupKFold, GroupShuffleSplit\n",
    "from sklearn.metrics import f1_score\n",
    "from sklearn.pipeline import Pipeline\n",
    "from sklearn.impute import SimpleImputer\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "from sklearn.linear_model import LogisticRegression\n",
    "from sklearn.ensemble import HistGradientBoostingClassifier\n",
    "from sklearn.utils.class_weight import compute_class_weight\n",
    "\n",
    "BASE = \"/kaggle/input/3w-dataset/2.0.0\"\n",
    "RANDOM_STATE = 42\n",
    "\n",
    "# خليه None عشان يبني كل WELL files (أفضل)\n",
    "# لو عايزة تجربة سريعة: حطي مثلا 400\n",
    "N_WELL_FILES = None\n",
    "\n",
    "OUT_DIR = \"/kaggle/working/3w_prepared_v3_1\"\n",
    "os.makedirs(OUT_DIR, exist_ok=True)\n",
    "\n",
    "print(\"OUT_DIR:\", OUT_DIR)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "d022179b",
   "metadata": {
    "_cell_guid": "43dd3beb-1e81-4aa6-ae49-562ace3591fc",
    "_uuid": "b5ce1d34-f068-49cd-a840-6f1a42682c0c",
    "collapsed": false,
    "execution": {
     "iopub.execute_input": "2025-12-31T21:36:21.387182Z",
     "iopub.status.busy": "2025-12-31T21:36:21.386204Z",
     "iopub.status.idle": "2025-12-31T21:36:23.782000Z",
     "shell.execute_reply": "2025-12-31T21:36:23.780879Z"
    },
    "jupyter": {
     "outputs_hidden": false
    },
    "papermill": {
     "duration": 2.403367,
     "end_time": "2025-12-31T21:36:23.783897",
     "exception": false,
     "start_time": "2025-12-31T21:36:21.380530",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Num files: 2228\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "source\n",
       "WELL         1119\n",
       "SIMULATED    1089\n",
       "DRAWN          20\n",
       "Name: count, dtype: int64"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "event_type_code\n",
       "0    594\n",
       "1    128\n",
       "2     38\n",
       "3    106\n",
       "4    343\n",
       "5    450\n",
       "6    221\n",
       "7     46\n",
       "8     95\n",
       "9    207\n",
       "Name: count, dtype: int64"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "WELL files: 1119\n"
     ]
    }
   ],
   "source": [
    "def build_file_index(base: str) -> pd.DataFrame:\n",
    "    paths = []\n",
    "    for root, _, files in os.walk(base):\n",
    "        for f in files:\n",
    "            if f.endswith(\".parquet\"):\n",
    "                paths.append(os.path.join(root, f))\n",
    "\n",
    "    df = pd.DataFrame({\"path\": paths})\n",
    "\n",
    "    df[\"event_type_code\"] = df[\"path\"].str.extract(r\"/2\\.0\\.0/(\\d+)/\").astype(int)\n",
    "    df[\"file\"] = df[\"path\"].str.split(\"/\").str[-1]\n",
    "    df[\"source\"] = df[\"file\"].str.extract(r\"^(WELL|SIMULATED|DRAWN)\")\n",
    "    df[\"well_id\"] = df[\"file\"].str.extract(r\"(WELL-\\d+)\")\n",
    "    df[\"run_ts\"] = df[\"file\"].str.extract(r\"_(\\d{14})\")\n",
    "    df[\"run_ts\"] = pd.to_datetime(df[\"run_ts\"], format=\"%Y%m%d%H%M%S\", errors=\"coerce\")\n",
    "\n",
    "    df = df.sort_values([\"event_type_code\",\"source\",\"well_id\",\"run_ts\"]).reset_index(drop=True)\n",
    "    return df\n",
    "\n",
    "df_files = build_file_index(BASE)\n",
    "\n",
    "print(\"Num files:\", len(df_files))\n",
    "display(df_files[\"source\"].value_counts(dropna=False))\n",
    "display(df_files[\"event_type_code\"].value_counts().sort_index())\n",
    "\n",
    "df_w_files = df_files[df_files[\"source\"]==\"WELL\"].reset_index(drop=True)\n",
    "print(\"WELL files:\", len(df_w_files))\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "b096c589",
   "metadata": {
    "_cell_guid": "7d3f90e3-30d8-4693-be35-bc8c37ad4f94",
    "_uuid": "ccb30fdb-e518-4f00-a9a7-92d2839e785d",
    "collapsed": false,
    "execution": {
     "iopub.execute_input": "2025-12-31T21:36:23.791887Z",
     "iopub.status.busy": "2025-12-31T21:36:23.791555Z",
     "iopub.status.idle": "2025-12-31T21:36:23.801045Z",
     "shell.execute_reply": "2025-12-31T21:36:23.800137Z"
    },
    "jupyter": {
     "outputs_hidden": false
    },
    "papermill": {
     "duration": 0.015693,
     "end_time": "2025-12-31T21:36:23.802770",
     "exception": false,
     "start_time": "2025-12-31T21:36:23.787077",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "VAR_RENAME = {\n",
    "    \"ABER-CKGL\": \"gl_choke_opening_pct\",\n",
    "    \"ABER-CKP\":  \"prod_choke_opening_pct\",\n",
    "    \"ESTADO-DHSV\":   \"dhsv_state\",\n",
    "    \"ESTADO-M1\":     \"prod_master_valve_state\",\n",
    "    \"ESTADO-M2\":     \"ann_master_valve_state\",\n",
    "    \"ESTADO-PXO\":    \"pig_crossover_valve_state\",\n",
    "    \"ESTADO-SDV-GL\": \"gl_shutdown_valve_state\",\n",
    "    \"ESTADO-SDV-P\":  \"prod_shutdown_valve_state\",\n",
    "    \"ESTADO-W1\":     \"prod_wing_valve_state\",\n",
    "    \"ESTADO-W2\":     \"ann_wing_valve_state\",\n",
    "    \"ESTADO-XO\":     \"crossover_valve_state\",\n",
    "    \"P-ANULAR\":     \"annulus_pressure_pa\",\n",
    "    \"P-JUS-BS\":     \"svc_pump_downstream_pressure_pa\",\n",
    "    \"P-JUS-CKGL\":   \"gl_choke_downstream_pressure_pa\",\n",
    "    \"P-JUS-CKP\":    \"prod_choke_downstream_pressure_pa\",\n",
    "    \"P-MON-CKGL\":   \"gl_choke_upstream_pressure_pa\",\n",
    "    \"P-MON-CKP\":    \"prod_choke_upstream_pressure_pa\",\n",
    "    \"P-MON-SDV-P\":  \"prod_sdv_upstream_pressure_pa\",\n",
    "    \"P-PDG\":        \"pdg_downhole_pressure_pa\",\n",
    "    \"PT-P\":         \"xmas_tree_prod_line_pressure_pa\",\n",
    "    \"P-TPT\":        \"tpt_pressure_pa\",\n",
    "    \"QBS\": \"svc_pump_flow_m3s\",\n",
    "    \"QGL\": \"gas_lift_flow_m3s\",\n",
    "    \"T-JUS-CKP\": \"prod_choke_downstream_temp_c\",\n",
    "    \"T-MON-CKP\": \"prod_choke_upstream_temp_c\",\n",
    "    \"T-PDG\":     \"pdg_downhole_temp_c\",\n",
    "    \"T-TPT\":     \"tpt_temp_c\",\n",
    "    \"class\": \"class_code\",\n",
    "    \"state\": \"state_code\",\n",
    "}\n",
    "\n",
    "EVENT_TYPE_CODE_TO_NAME = {\n",
    "    0:\"Normal Operation\", 1:\"Abrupt Increase of BSW\", 2:\"Spurious Closure of DHSV\",\n",
    "    3:\"Severe Slugging\", 4:\"Flow Instability\", 5:\"Rapid Productivity Loss\",\n",
    "    6:\"Quick Restriction in PCK\", 7:\"Scaling in PCK\",\n",
    "    8:\"Hydrate in Production Line\", 9:\"Hydrate in Service Line\",\n",
    "}\n",
    "\n",
    "LABEL_COLS = {\"class_code\", \"state_code\", \"class_label\", \"state_label\"}\n",
    "\n",
    "def clean_3w_instance(df: pd.DataFrame) -> pd.DataFrame:\n",
    "    df = df.copy()\n",
    "\n",
    "    if \"timestamp\" in df.columns:\n",
    "        df[\"timestamp\"] = pd.to_datetime(df[\"timestamp\"], errors=\"coerce\")\n",
    "        df = df.set_index(\"timestamp\")\n",
    "    else:\n",
    "        df.index = pd.to_datetime(df.index, errors=\"coerce\")\n",
    "\n",
    "    df = df[~df.index.isna()].sort_index()\n",
    "    df.index.name = \"timestamp\"\n",
    "\n",
    "    df = df.rename(columns=VAR_RENAME)\n",
    "\n",
    "    for c in df.columns:\n",
    "        if c in (\"class_code\", \"state_code\"):\n",
    "            df[c] = pd.to_numeric(df[c], errors=\"coerce\").astype(\"Int16\")\n",
    "        else:\n",
    "            df[c] = pd.to_numeric(df[c], errors=\"coerce\").astype(\"float64\")\n",
    "\n",
    "    return df\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "1d2a6b43",
   "metadata": {
    "_cell_guid": "5d497b20-eeb4-40ac-b462-9dca2ca076e3",
    "_uuid": "00df3321-d196-4aa5-b89b-ec6a55e7336b",
    "collapsed": false,
    "execution": {
     "iopub.execute_input": "2025-12-31T21:36:23.811131Z",
     "iopub.status.busy": "2025-12-31T21:36:23.810378Z",
     "iopub.status.idle": "2025-12-31T21:36:23.824734Z",
     "shell.execute_reply": "2025-12-31T21:36:23.823786Z"
    },
    "jupyter": {
     "outputs_hidden": false
    },
    "papermill": {
     "duration": 0.020593,
     "end_time": "2025-12-31T21:36:23.826478",
     "exception": false,
     "start_time": "2025-12-31T21:36:23.805885",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "def summarize_timeseries_v3_1(df_clean: pd.DataFrame, frac: float = 0.1, state_max: int = 3) -> dict:\n",
    "    sensors = df_clean.drop(columns=list(LABEL_COLS), errors=\"ignore\")\n",
    "    num = sensors.select_dtypes(include=[np.number])\n",
    "\n",
    "    out = {\n",
    "        \"n_obs\": int(len(df_clean)),\n",
    "        \"duration_s\": float((df_clean.index.max() - df_clean.index.min()).total_seconds())\n",
    "                      if len(df_clean) else np.nan,\n",
    "    }\n",
    "    if num.shape[1] == 0 or len(num) == 0:\n",
    "        return out\n",
    "\n",
    "    # ✅ الصح: state columns حسب الاسم\n",
    "    state_cols = [c for c in num.columns if c.endswith(\"_state\")]\n",
    "    cont_cols  = [c for c in num.columns if c not in state_cols]\n",
    "\n",
    "    # ---------- continuous features ----------\n",
    "    if len(cont_cols):\n",
    "        cont = num[cont_cols]\n",
    "\n",
    "        # raw features (absolute level across wells)\n",
    "        med_raw = cont.median()\n",
    "        iqr_raw = (cont.quantile(0.75) - cont.quantile(0.25))\n",
    "\n",
    "        # robust-z within file\n",
    "        iqr = iqr_raw.replace(0, np.nan)\n",
    "        z = (cont - med_raw) / iqr\n",
    "\n",
    "        k = max(1, int(len(z) * frac))\n",
    "        first = z.iloc[:k].mean()\n",
    "        last  = z.iloc[-k:].mean()\n",
    "\n",
    "        agg = z.agg([\"mean\",\"std\",\"min\",\"max\"]).T\n",
    "        miss = cont.isna().mean()\n",
    "\n",
    "        for col in cont_cols:\n",
    "            out[f\"{col}__raw_median\"] = med_raw[col]\n",
    "            out[f\"{col}__raw_iqr\"]    = iqr_raw[col]\n",
    "            out[f\"{col}__raw_last\"]   = cont[col].iloc[-1]\n",
    "\n",
    "            out[f\"{col}__z_mean\"] = agg.loc[col, \"mean\"]\n",
    "            out[f\"{col}__z_std\"]  = agg.loc[col, \"std\"]\n",
    "            out[f\"{col}__z_min\"]  = agg.loc[col, \"min\"]\n",
    "            out[f\"{col}__z_max\"]  = agg.loc[col, \"max\"]\n",
    "            out[f\"{col}__z_last\"] = z[col].iloc[-1]\n",
    "\n",
    "            out[f\"{col}__delta_last_first\"] = (last[col] - first[col])\n",
    "            out[f\"{col}__abs_delta\"]        = abs(last[col] - first[col])\n",
    "            out[f\"{col}__missing_frac\"]     = miss[col]\n",
    "\n",
    "    # ---------- state features ----------\n",
    "    if len(state_cols):\n",
    "        st = num[state_cols]\n",
    "        for col in state_cols:\n",
    "            s = st[col]\n",
    "            s_non = s.dropna()\n",
    "\n",
    "            out[f\"{col}__missing_frac\"] = float(s.isna().mean())\n",
    "            out[f\"{col}__last\"] = float(s_non.iloc[-1]) if len(s_non) else np.nan\n",
    "\n",
    "            if len(s_non) >= 2:\n",
    "                n_trans = int((s_non != s_non.shift()).sum() - 1)\n",
    "            else:\n",
    "                n_trans = 0\n",
    "\n",
    "            out[f\"{col}__n_transitions\"] = n_trans\n",
    "            out[f\"{col}__transitions_rate\"] = n_trans / max(1, len(s_non))\n",
    "\n",
    "            # proportions for known states\n",
    "            known = 0.0\n",
    "            for v in range(state_max + 1):\n",
    "                p = float((s_non == v).mean()) if len(s_non) else np.nan\n",
    "                out[f\"{col}__p_state_{v}\"] = p\n",
    "                if not np.isnan(p):\n",
    "                    known += p\n",
    "\n",
    "            # ✅ any other state goes here\n",
    "            out[f\"{col}__p_state_other\"] = (1.0 - known) if len(s_non) else np.nan\n",
    "\n",
    "\n",
    "    return out\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "88c7f218",
   "metadata": {
    "_cell_guid": "a5e900d0-cb5b-4f37-8984-ac7e340f4dcf",
    "_uuid": "2bf22d68-f92b-4b74-b046-05686ad32cc8",
    "collapsed": false,
    "execution": {
     "iopub.execute_input": "2025-12-31T21:36:23.834515Z",
     "iopub.status.busy": "2025-12-31T21:36:23.834209Z",
     "iopub.status.idle": "2025-12-31T21:38:25.583886Z",
     "shell.execute_reply": "2025-12-31T21:38:25.582910Z"
    },
    "jupyter": {
     "outputs_hidden": false
    },
    "papermill": {
     "duration": 121.756146,
     "end_time": "2025-12-31T21:38:25.585790",
     "exception": false,
     "start_time": "2025-12-31T21:36:23.829644",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "4b6d3c2451bb4e0c84a8a36291b22ba0",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "Building WELL dataset:   0%|          | 0/1119 [00:00<?, ?it/s]"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "df_ml_well shape: (1119, 287)\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "event_type_code\n",
       "0    594\n",
       "1      4\n",
       "2     22\n",
       "3     32\n",
       "4    343\n",
       "5     11\n",
       "6      6\n",
       "7     36\n",
       "8     14\n",
       "9     57\n",
       "Name: count, dtype: int64"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Saved to: /kaggle/working/3w_prepared_v3_1\n"
     ]
    }
   ],
   "source": [
    "def build_row_per_file_dataset(df_files: pd.DataFrame, n_files: int | None = None, random_state: int = 42) -> pd.DataFrame:\n",
    "    if n_files is None:\n",
    "        sample = df_files.reset_index(drop=True)\n",
    "    else:\n",
    "        sample = df_files.sample(n_files, random_state=random_state).reset_index(drop=True)\n",
    "\n",
    "    rows = []\n",
    "    for _, r in tqdm(sample.iterrows(), total=len(sample), desc=\"Building WELL dataset\"):\n",
    "        df_raw = pd.read_parquet(r[\"path\"])\n",
    "        df_clean = clean_3w_instance(df_raw)\n",
    "\n",
    "        feats = summarize_timeseries_v3_1(df_clean)\n",
    "\n",
    "        feats[\"event_type_code\"] = int(r[\"event_type_code\"])\n",
    "        feats[\"event_type_name\"] = EVENT_TYPE_CODE_TO_NAME.get(int(r[\"event_type_code\"]), \"Unknown\")\n",
    "        feats[\"source\"] = r[\"source\"]\n",
    "        feats[\"well_id\"] = r[\"well_id\"]\n",
    "        feats[\"run_ts\"] = r[\"run_ts\"]\n",
    "        feats[\"file\"] = r[\"file\"]\n",
    "        rows.append(feats)\n",
    "\n",
    "    return pd.DataFrame(rows)\n",
    "\n",
    "df_ml_well = build_row_per_file_dataset(df_w_files, n_files=N_WELL_FILES, random_state=RANDOM_STATE)\n",
    "\n",
    "print(\"df_ml_well shape:\", df_ml_well.shape)\n",
    "display(df_ml_well[\"event_type_code\"].value_counts().sort_index())\n",
    "\n",
    "# Save\n",
    "df_w_files.to_parquet(f\"{OUT_DIR}/df_w_files.parquet\", index=False)\n",
    "df_ml_well.to_parquet(f\"{OUT_DIR}/df_ml_well_v3_1.parquet\", index=False)\n",
    "\n",
    "config = {\n",
    "    \"base\": BASE,\n",
    "    \"random_state\": RANDOM_STATE,\n",
    "    \"n_well_files_used\": int(len(df_ml_well)),\n",
    "    \"features_version\": \"row_per_file_v3_1\",\n",
    "    \"notes\": \"continuous: raw median/iqr/last + robust-z stats + deltas; state: last + transitions + proportions; WELL-only\"\n",
    "}\n",
    "with open(f\"{OUT_DIR}/dataset_config.json\", \"w\") as f:\n",
    "    json.dump(config, f, indent=2)\n",
    "\n",
    "print(\"Saved to:\", OUT_DIR)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "ea469785",
   "metadata": {
    "_cell_guid": "748967c6-a301-43fc-aa70-f18ecb471c02",
    "_uuid": "156c73be-d8bf-4d25-906b-a2c1247ea4b6",
    "collapsed": false,
    "execution": {
     "iopub.execute_input": "2025-12-31T21:38:25.594055Z",
     "iopub.status.busy": "2025-12-31T21:38:25.593701Z",
     "iopub.status.idle": "2025-12-31T21:38:25.628199Z",
     "shell.execute_reply": "2025-12-31T21:38:25.627142Z"
    },
    "jupyter": {
     "outputs_hidden": false
    },
    "papermill": {
     "duration": 0.040758,
     "end_time": "2025-12-31T21:38:25.629986",
     "exception": false,
     "start_time": "2025-12-31T21:38:25.589228",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "X shape: (1119, 182) y: (1119,) num wells: 40\n"
     ]
    }
   ],
   "source": [
    "def make_Xy_groups(df: pd.DataFrame):\n",
    "    y = df[\"event_type_code\"].copy()\n",
    "    groups = df[\"well_id\"].copy()\n",
    "\n",
    "    drop_cols = [\"event_type_code\",\"event_type_name\",\"file\",\"run_ts\",\"well_id\",\"source\"]\n",
    "    X = df.drop(columns=drop_cols, errors=\"ignore\").copy()\n",
    "\n",
    "    X = X.replace([np.inf, -np.inf], np.nan)\n",
    "\n",
    "    # drop global all-missing\n",
    "    X = X.drop(columns=X.columns[X.isna().all()])\n",
    "\n",
    "    # drop very high missing\n",
    "    miss = X.isna().mean()\n",
    "    X = X.drop(columns=miss[miss > 0.98].index)\n",
    "\n",
    "    # drop constants\n",
    "    const_cols = [c for c in X.columns if X[c].nunique(dropna=True) <= 1]\n",
    "    X = X.drop(columns=const_cols)\n",
    "\n",
    "    return X, y, groups\n",
    "\n",
    "X, y, groups = make_Xy_groups(df_ml_well)\n",
    "print(\"X shape:\", X.shape, \"y:\", y.shape, \"num wells:\", groups.nunique())\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "6c38b63f",
   "metadata": {
    "_cell_guid": "e72a6406-9757-472a-be10-a7d0b5b812bb",
    "_uuid": "4d6ecf6c-26d6-4f0c-bfe4-2e0fc82a5b7d",
    "collapsed": false,
    "execution": {
     "iopub.execute_input": "2025-12-31T21:38:25.638422Z",
     "iopub.status.busy": "2025-12-31T21:38:25.638123Z",
     "iopub.status.idle": "2025-12-31T21:38:25.650432Z",
     "shell.execute_reply": "2025-12-31T21:38:25.649498Z"
    },
    "jupyter": {
     "outputs_hidden": false
    },
    "papermill": {
     "duration": 0.018749,
     "end_time": "2025-12-31T21:38:25.652301",
     "exception": false,
     "start_time": "2025-12-31T21:38:25.633552",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "def eval_sgkf(model, X, y, groups, n_splits=3):\n",
    "    sgkf = StratifiedGroupKFold(n_splits=n_splits, shuffle=True, random_state=42)\n",
    "\n",
    "    major_classes = set(y.value_counts()[lambda s: s >= 10].index)\n",
    "\n",
    "    f1s, f1_major, f1_bin = [], [], []\n",
    "    for tr, te in sgkf.split(X, y, groups=groups):\n",
    "        Xtr, Xte = X.iloc[tr], X.iloc[te]\n",
    "        ytr, yte = y.iloc[tr], y.iloc[te]\n",
    "\n",
    "        model.fit(Xtr, ytr)\n",
    "        pred = model.predict(Xte)\n",
    "\n",
    "        f1s.append(f1_score(yte, pred, average=\"macro\"))\n",
    "\n",
    "        mask = yte.isin(major_classes)\n",
    "        f1_major.append(f1_score(yte[mask], pred[mask], average=\"macro\") if mask.sum() else np.nan)\n",
    "\n",
    "        yte_bin = (yte != 0).astype(int)\n",
    "        pred_bin = (pred != 0).astype(int)\n",
    "        f1_bin.append(f1_score(yte_bin, pred_bin))\n",
    "\n",
    "    return {\n",
    "        \"macro_f1_mean\": float(np.nanmean(f1s)),\n",
    "        \"macro_f1_std\":  float(np.nanstd(f1s)),\n",
    "        \"major_macro_f1_mean\": float(np.nanmean(f1_major)),\n",
    "        \"fault_vs_normal_f1_mean\": float(np.nanmean(f1_bin)),\n",
    "    }\n",
    "\n",
    "def eval_repeated_group_shuffle(model, X, y, groups, repeats=30, test_size=0.2):\n",
    "    gss = GroupShuffleSplit(n_splits=repeats, test_size=test_size, random_state=42)\n",
    "\n",
    "    major_classes = set(y.value_counts()[lambda s: s >= 10].index)\n",
    "\n",
    "    f1s, f1_major, f1_bin = [], [], []\n",
    "    for tr, te in gss.split(X, y, groups=groups):\n",
    "        Xtr, Xte = X.iloc[tr], X.iloc[te]\n",
    "        ytr, yte = y.iloc[tr], y.iloc[te]\n",
    "\n",
    "        model.fit(Xtr, ytr)\n",
    "        pred = model.predict(Xte)\n",
    "\n",
    "        f1s.append(f1_score(yte, pred, average=\"macro\"))\n",
    "\n",
    "        mask = yte.isin(major_classes)\n",
    "        f1_major.append(f1_score(yte[mask], pred[mask], average=\"macro\") if mask.sum() else np.nan)\n",
    "\n",
    "        yte_bin = (yte != 0).astype(int)\n",
    "        pred_bin = (pred != 0).astype(int)\n",
    "        f1_bin.append(f1_score(yte_bin, pred_bin))\n",
    "\n",
    "    return {\n",
    "        \"macro_f1_mean\": float(np.nanmean(f1s)),\n",
    "        \"macro_f1_std\":  float(np.nanstd(f1s)),\n",
    "        \"major_macro_f1_mean\": float(np.nanmean(f1_major)),\n",
    "        \"fault_vs_normal_f1_mean\": float(np.nanmean(f1_bin)),\n",
    "    }\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "b130e481",
   "metadata": {
    "_cell_guid": "e7e44434-cf08-4c2c-9e15-cf27f36451af",
    "_uuid": "5b784f80-d74e-4e61-9a2e-0bee80537905",
    "collapsed": false,
    "execution": {
     "iopub.execute_input": "2025-12-31T21:38:25.660546Z",
     "iopub.status.busy": "2025-12-31T21:38:25.660251Z",
     "iopub.status.idle": "2025-12-31T21:49:40.107580Z",
     "shell.execute_reply": "2025-12-31T21:49:40.106697Z"
    },
    "jupyter": {
     "outputs_hidden": false
    },
    "papermill": {
     "duration": 674.457923,
     "end_time": "2025-12-31T21:49:40.113664",
     "exception": false,
     "start_time": "2025-12-31T21:38:25.655741",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "=== SGKF(3) ===\n",
      "LogReg: {'macro_f1_mean': 0.2132743351703038, 'macro_f1_std': 0.020872956678484964, 'major_macro_f1_mean': 0.24202320934891675, 'fault_vs_normal_f1_mean': 0.5400034564961553}\n",
      "HGB   : {'macro_f1_mean': 0.3897749108071133, 'macro_f1_std': 0.13416882763152274, 'major_macro_f1_mean': 0.43790063841762167, 'fault_vs_normal_f1_mean': 0.7405608715894342}\n",
      "\n",
      "=== Repeated GroupShuffle (30) ===\n",
      "LogReg: {'macro_f1_mean': 0.2220844412708708, 'macro_f1_std': 0.09474106156164713, 'major_macro_f1_mean': 0.24584133361326016, 'fault_vs_normal_f1_mean': 0.6082033788273894}\n",
      "HGB   : {'macro_f1_mean': 0.41743879159789393, 'macro_f1_std': 0.153304009843824, 'major_macro_f1_mean': 0.4371282389527981, 'fault_vs_normal_f1_mean': 0.7646731967383822}\n"
     ]
    }
   ],
   "source": [
    "# Logistic baseline (robust to missing)\n",
    "logreg = Pipeline([\n",
    "    (\"imputer\", SimpleImputer(strategy=\"constant\", fill_value=0, add_indicator=True)),\n",
    "    (\"scaler\", StandardScaler(with_mean=False)),\n",
    "    (\"clf\", LogisticRegression(max_iter=8000, class_weight=\"balanced\"))\n",
    "])\n",
    "\n",
    "# HGB with class-weights via sample_weight\n",
    "class HGBWrapper:\n",
    "    def __init__(self, max_depth=6, learning_rate=0.08, max_iter=400):\n",
    "        self.clf = HistGradientBoostingClassifier(\n",
    "    max_depth=6,\n",
    "    learning_rate=0.06,\n",
    "    max_iter=700,\n",
    "    max_leaf_nodes=31,\n",
    "    min_samples_leaf=20,\n",
    "    l2_regularization=0.1\n",
    ")\n",
    "\n",
    "    def fit(self, X, y):\n",
    "        classes = np.unique(y)\n",
    "        cw = compute_class_weight(class_weight=\"balanced\", classes=classes, y=y)\n",
    "        w = pd.Series(y).map(dict(zip(classes, cw))).to_numpy()\n",
    "        # HGB doesn't accept NaN in older setups sometimes -> fillna(0) safe\n",
    "        self.clf.fit(X.fillna(0), y, sample_weight=w)\n",
    "        return self\n",
    "    def predict(self, X):\n",
    "        return self.clf.predict(X.fillna(0))\n",
    "\n",
    "hgb = HGBWrapper(max_depth=6, learning_rate=0.08, max_iter=500)\n",
    "\n",
    "print(\"=== SGKF(3) ===\")\n",
    "print(\"LogReg:\", eval_sgkf(logreg, X, y, groups, n_splits=3))\n",
    "print(\"HGB   :\", eval_sgkf(hgb, X, y, groups, n_splits=3))\n",
    "\n",
    "print(\"\\n=== Repeated GroupShuffle (30) ===\")\n",
    "print(\"LogReg:\", eval_repeated_group_shuffle(logreg, X, y, groups, repeats=30))\n",
    "print(\"HGB   :\", eval_repeated_group_shuffle(hgb, X, y, groups, repeats=30))\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "95507c1e",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-12-31T21:49:40.122145Z",
     "iopub.status.busy": "2025-12-31T21:49:40.121875Z",
     "iopub.status.idle": "2025-12-31T21:50:10.971675Z",
     "shell.execute_reply": "2025-12-31T21:50:10.970882Z"
    },
    "papermill": {
     "duration": 30.859971,
     "end_time": "2025-12-31T21:50:10.977179",
     "exception": false,
     "start_time": "2025-12-31T21:49:40.117208",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Fold 1 macro-F1 = 0.521 | test size=180 | unique classes in test=6\n",
      "Fold 2 macro-F1 = 0.443 | test size=422 | unique classes in test=9\n",
      "Fold 3 macro-F1 = 0.206 | test size=517 | unique classes in test=10\n",
      "Mean: 0.3897749108071133 Std: 0.13416882763152274\n"
     ]
    }
   ],
   "source": [
    "def debug_sgkf_folds(model, X, y, groups, n_splits=3):\n",
    "    sgkf = StratifiedGroupKFold(n_splits=n_splits, shuffle=True, random_state=42)\n",
    "    fold_scores = []\n",
    "    for i, (tr, te) in enumerate(sgkf.split(X, y, groups=groups), 1):\n",
    "        model.fit(X.iloc[tr], y.iloc[tr])\n",
    "        pred = model.predict(X.iloc[te])\n",
    "        f1 = f1_score(y.iloc[te], pred, average=\"macro\")\n",
    "        fold_scores.append(f1)\n",
    "        print(f\"Fold {i} macro-F1 = {f1:.3f} | test size={len(te)} | unique classes in test={y.iloc[te].nunique()}\")\n",
    "    print(\"Mean:\", np.mean(fold_scores), \"Std:\", np.std(fold_scores))\n",
    "\n",
    "debug_sgkf_folds(hgb, X, y, groups, n_splits=3)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f18db1b4",
   "metadata": {
    "papermill": {
     "duration": 0.003498,
     "end_time": "2025-12-31T21:50:10.984217",
     "exception": false,
     "start_time": "2025-12-31T21:50:10.980719",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kaggle": {
   "accelerator": "none",
   "dataSources": [
    {
     "datasetId": 988298,
     "sourceId": 9353254,
     "sourceType": "datasetVersion"
    }
   ],
   "dockerImageVersionId": 31234,
   "isGpuEnabled": false,
   "isInternetEnabled": true,
   "language": "python",
   "sourceType": "notebook"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.12"
  },
  "papermill": {
   "default_parameters": {},
   "duration": 835.894246,
   "end_time": "2025-12-31T21:50:11.608095",
   "environment_variables": {},
   "exception": null,
   "input_path": "__notebook__.ipynb",
   "output_path": "__notebook__.ipynb",
   "parameters": {},
   "start_time": "2025-12-31T21:36:15.713849",
   "version": "2.6.0"
  },
  "widgets": {
   "application/vnd.jupyter.widget-state+json": {
    "state": {
     "0a8557ca2f49479380800513853e8f1a": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "4b6d3c2451bb4e0c84a8a36291b22ba0": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HBoxModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HBoxModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HBoxView",
       "box_style": "",
       "children": [
        "IPY_MODEL_7bdca66330d740dca5a9499cb91987d3",
        "IPY_MODEL_94db343948794eb2ad2464fcf8b8d624",
        "IPY_MODEL_4c9d3418bd244241aba11f906b132312"
       ],
       "layout": "IPY_MODEL_b4ba70fd9f6949408bdaac89ff8ac395",
       "tabbable": null,
       "tooltip": null
      }
     },
     "4c9d3418bd244241aba11f906b132312": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_7ee01c3a420241b2a9cfd4c671eaa9f4",
       "placeholder": "​",
       "style": "IPY_MODEL_bb2b2820d9e5479884dab01142a8fd9f",
       "tabbable": null,
       "tooltip": null,
       "value": " 1119/1119 [02:01&lt;00:00,  7.22it/s]"
      }
     },
     "7bdca66330d740dca5a9499cb91987d3": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "HTMLView",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_cfbb12b06b10480c807d5537310a7d5a",
       "placeholder": "​",
       "style": "IPY_MODEL_7ef5fcbc64a641a9b07b2cda4916b73b",
       "tabbable": null,
       "tooltip": null,
       "value": "Building WELL dataset: 100%"
      }
     },
     "7ee01c3a420241b2a9cfd4c671eaa9f4": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "7ef5fcbc64a641a9b07b2cda4916b73b": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "94db343948794eb2ad2464fcf8b8d624": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "FloatProgressModel",
      "state": {
       "_dom_classes": [],
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "FloatProgressModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/controls",
       "_view_module_version": "2.0.0",
       "_view_name": "ProgressView",
       "bar_style": "success",
       "description": "",
       "description_allow_html": false,
       "layout": "IPY_MODEL_0a8557ca2f49479380800513853e8f1a",
       "max": 1119.0,
       "min": 0.0,
       "orientation": "horizontal",
       "style": "IPY_MODEL_d35f6a239e954f2e90f6d502e388d3a1",
       "tabbable": null,
       "tooltip": null,
       "value": 1119.0
      }
     },
     "b4ba70fd9f6949408bdaac89ff8ac395": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "bb2b2820d9e5479884dab01142a8fd9f": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "HTMLStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "HTMLStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "background": null,
       "description_width": "",
       "font_size": null,
       "text_color": null
      }
     },
     "cfbb12b06b10480c807d5537310a7d5a": {
      "model_module": "@jupyter-widgets/base",
      "model_module_version": "2.0.0",
      "model_name": "LayoutModel",
      "state": {
       "_model_module": "@jupyter-widgets/base",
       "_model_module_version": "2.0.0",
       "_model_name": "LayoutModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "LayoutView",
       "align_content": null,
       "align_items": null,
       "align_self": null,
       "border_bottom": null,
       "border_left": null,
       "border_right": null,
       "border_top": null,
       "bottom": null,
       "display": null,
       "flex": null,
       "flex_flow": null,
       "grid_area": null,
       "grid_auto_columns": null,
       "grid_auto_flow": null,
       "grid_auto_rows": null,
       "grid_column": null,
       "grid_gap": null,
       "grid_row": null,
       "grid_template_areas": null,
       "grid_template_columns": null,
       "grid_template_rows": null,
       "height": null,
       "justify_content": null,
       "justify_items": null,
       "left": null,
       "margin": null,
       "max_height": null,
       "max_width": null,
       "min_height": null,
       "min_width": null,
       "object_fit": null,
       "object_position": null,
       "order": null,
       "overflow": null,
       "padding": null,
       "right": null,
       "top": null,
       "visibility": null,
       "width": null
      }
     },
     "d35f6a239e954f2e90f6d502e388d3a1": {
      "model_module": "@jupyter-widgets/controls",
      "model_module_version": "2.0.0",
      "model_name": "ProgressStyleModel",
      "state": {
       "_model_module": "@jupyter-widgets/controls",
       "_model_module_version": "2.0.0",
       "_model_name": "ProgressStyleModel",
       "_view_count": null,
       "_view_module": "@jupyter-widgets/base",
       "_view_module_version": "2.0.0",
       "_view_name": "StyleView",
       "bar_color": null,
       "description_width": ""
      }
     }
    },
    "version_major": 2,
    "version_minor": 0
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
